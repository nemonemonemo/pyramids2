var webgl, gui;

  var videoInput = document.getElementById('inputVideo');
  var canvasInput = document.getElementById('inputCanvas');



var ht = new headtrackr.Tracker({ui : true, headPosition : true})
  ht.init(videoInput, canvasInput);
  ht.start();






 

$(document).ready(init);



// setInterval(function(){
//   ht.stop();
//   ht.start();
// }, 2000);




// function handleFaceTrackingEvent(e){

//   console.log("facetrack:: "+(event.x-150));
// }

// document.addEventListener('facetrackingEvent', handleFaceTrackingEvent);


 


function init(){
    webgl = new Webgl(window.innerWidth, window.innerHeight);
    

    // gui = new dat.GUI();
    // // gui.add(webgl.pyramid2.rotation, 'x').step(0.01).min(-Math.PI).max(Math.PI);
    // // gui.add(webgl.pyramid2.rotation, 'y').step(0.01).min(-Math.PI).max(Math.PI);
    // // gui.add(webgl.pyramid2.rotation, 'z').step(0.01).min(-Math.PI).max(Math.PI);
    // gui.close();

    $(window).on('resize', resizeHandler);

    animate();
    $(document).on('facetrackingEvent',  webgl.onHeadMove.bind(webgl));

    $('#activateButton').click(function(){

        if( $('#activateButton').text() == "I think the webcam is broken"){
          ht.stop();
          ht.start();
        }else{
          $(document).on('mousemove',  webgl.onMouseMove.bind(webgl));
          $(this).hide();
        }

    });



  document.addEventListener('headtrackrStatus', 
  function (event) {


    if (event.status == "camera found") {
      $('#activateButton').text("I think the webcam is broken")

       $('#activateButton').css ( "left" , "60%");

       $('#hideShowCam').fadeIn("fast");
       $('#hideShowCam').addClass("animButtonShow");
       

       $('#hideShowCam').click( function(){
         if ($('#hideShowCam').text() =="Please, hide my face!"){
            $('#hideShowCam').text("Please, show my face!");
            $("#inputCanvas").fadeOut("fast");
          }else{
            $('#hideShowCam').text("Please, hide my face!");
            $("#inputCanvas").fadeIn("fast");
          }
       });
    }
     
    if (event.status == "redetecting") {
      webgl.flag = true;
    }
   
  }
);


}



function resizeHandler() {
    webgl.resize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    // webgl.setTracking()
    webgl.render();
}
var Webgl = (function(){

    function Webgl(width, height){
        // Basic three.js setup
        this.scene = new THREE.Scene();
        
        this.camera = new THREE.PerspectiveCamera(20, width / height, 1, 10000);
        //this.camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 100, 1000 );
        this.distance = 500; 
        this.camera.position.z = this.distance;

        this.camera.lookAt(new THREE.Vector3(0,0,0));

        this.renderer = new THREE.WebGLRenderer();
        this.renderer.setSize(width, height);
        this.renderer.setClearColor(0xb5cbd3);
        $('.three').append(this.renderer.domElement);


        // this.controls = new THREE.TrackballControls( this.camera );

        // this.controls.rotateSpeed = 1.0;
        // this.controls.zoomSpeed = 1.2;
        // this.controls.panSpeed = 0.8;

        // this.controls.noZoom = false;
        // this.controls.noPan = false;

        // this.controls.staticMoving = true;
        // this.controls.dynamicDampingFactor = 0.3;

        // this.controls.keys = [ 65, 83, 68 ];

        
        this.pyramid = new Pyramid();
        this.pyramid.position.set(0, 0, 0);
        this.pyramid.rotation.x = Math.PI;
        this.pyramid.rotation.y = Math.PI*0.25;
        this.scene.add(this.pyramid);

        

        this.pyramid2 = new Pyramid();
        this.pyramid2.position.set(-40, 0, 0);
        this.pyramid2.rotation.y = Math.PI*0.25;
        this.scene.add(this.pyramid2);



        this.pyramid3 = new Pyramid();
        this.pyramid3.position.set(40, 0, 0);
        this.pyramid3.rotation.y = Math.PI*0.25;
        this.scene.add(this.pyramid3);

        this.flag= true;
       

        this.light = new THREE.PointLight( 0xffffff, 1, 1000 );
        this.light.position.set( 0, 200, 0 );
        this.scene.add( this.light );

        this.light2 = new THREE.PointLight( 0xffffff, 1, 1000 );
        this.light2.position.set( 0, -200, 0 );
        this.scene.add( this.light2 );


        


        this.composer = new THREE.EffectComposer( this.renderer );
        this.composer.addPass( new THREE.RenderPass( this.scene, this.camera ) );


        this.hblur = new THREE.ShaderPass( THREE.HorizontalBlurShader );
        this.hblur.uniforms.h.value = 1/6000;
        this.composer.addPass( this.hblur );


        this.vignette = new THREE.ShaderPass( THREE.VignetteShader );
        this.vignette.uniforms.darkness.value = 0.8;
        this.vignette.renderToScreen = true;
        this.composer.addPass( this.vignette );


        this.oldPosX = this.camera.position.x;

        this.smoothCam = this.camera.position.x;

        this.valueIntroPyramid = (3*Math.PI)+Math.PI*0.25;

        this.animPyramid(this.pyramid, 0.5, -this.valueIntroPyramid);

        this.animPyramid(this.pyramid2, 0.3, this.valueIntroPyramid);

        this.animPyramid(this.pyramid3, 0.8, this.valueIntroPyramid);
        

        
   
    }



   Webgl.prototype.onMouseMove= function(event){
    mouseX = (event.clientX - window.innerWidth/2) / window.innerWidth/2;
    mouseY = (event.clientY - window.innerHeight/2) / window.innerHeight/2;
    this.camera.position.x = Math.sin(mouseX * Math.PI) * this.distance;
    this.camera.position.y = - Math.sin(mouseY * Math.PI) * this.distance;
    this.camera.lookAt(new THREE.Vector3(0,0,0));


    console.log(mouseY);

     if (this.flag== true && mouseX < -0.24 ){
        console.log("left");
        this.flag = false;
        this.pyramid.explode();
        this.pyramid2.explode();
        this.pyramid3.explode();



    }

    if (this.flag== true && mouseX >0.24  ){
        console.log("left");
        this.flag = false;
        this.pyramid.explode();
        this.pyramid2.explode();
        this.pyramid3.explode();



    }



    if (this.flag== true && mouseY < -0.24  ){
        console.log("left");
        this.flag = false;
        this.pyramid.explode();
        this.pyramid2.explode();
        this.pyramid3.explode();
       
        
        
    }



    if (this.flag== true && mouseY >0.24  ){
        console.log("left");
        this.flag = false;
        this.pyramid.explode();
        this.pyramid2.explode();
        this.pyramid3.explode();
    }



    if((mouseX > -0.24 && mouseX <0.24 && mouseY > -0.24 && mouseY < 0.24)){
    this.flag = true;
    console.log("eventX ::"+event.x)
    this.pyramid.rebootPyamid();
    this.pyramid2.rebootPyamid();
    this.pyramid3.rebootPyamid();

    }

   
}



    Webgl.prototype.animPyramid= function(pyramid, delay, animY ) {


        TweenLite.to(pyramid.rotation ,1.2, {
            y : animY,
            delay: delay,
            ease:Power2.easeOut
         
        });
    }





    Webgl.prototype.resize = function(width, height) {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    };



    Webgl.prototype.onHeadMove= function(e){

       
        eventX = event.x;
        webcamWidth = 320/2;
        ratioX = window.innerWidth / webcamWidth; 
        posHeadX = ratioX*event.x;

        this.destValueX = (event.x-webcamWidth)*ratioX;

        eventY = event.y;
        webcamHeight = 240/2;
        ratioY = window.innerWidth / webcamHeight; 
        posHeadX = ratioY*event.Y;

        this.destValueY = (event.y-webcamHeight)*ratioY;


        
        //console.log("widthEvent ::"+event.x)
         
        //this.smoothCam += (this.destValue - this.smoothCam) * 0.1;
        this.camera.position.x = this.destValueX;
        this.camera.position.y = this.destValueY;

        

        this.camera.lookAt(new THREE.Vector3(0,0,0));
        

         if (this.flag== true && event.x <50 ){
            console.log("left");
            this.flag = false;
            this.pyramid.explode();
            this.pyramid2.explode();
            this.pyramid3.explode();
           
            
            
        }

        if (this.flag== true && event.x >280 ){
            console.log("left");
            this.flag = false;
            this.pyramid.explode();
            this.pyramid2.explode();
            this.pyramid3.explode();
           
            
            
        }


        if (this.flag== true && event.y <50 ){
            console.log("left");
            this.flag = false;
            this.pyramid.explode();
            this.pyramid2.explode();
            this.pyramid3.explode();
           
            
            
        }



        if (this.flag== true && event.y >190 ){
            console.log("left");
            this.flag = false;
            this.pyramid.explode();
            this.pyramid2.explode();
            this.pyramid3.explode();
        }


        if((event.x <280 && event.x>50 && event.y <190 && event.y>50)){
            this.flag = true;
            console.log("eventX ::"+event.x)
            this.pyramid.rebootPyamid();
            this.pyramid2.rebootPyamid();
            this.pyramid3.rebootPyamid();
        
        }

        // if (this.flag== true && this.camera.position.x< -(window.innerWidth/2)){
            
        //     console.log("right");
        //     this.flag = false;

            
        //    this.pyramid.explode();
        //    this.pyramid2.explode();
        //    this.pyramid3.explode();
        
        
            
        // }



            
        

  


    }

    

    Webgl.prototype.render = function() { 

        var audio = new Audio('../../styles/sounds/effect.mp3');
        

        //TWEEN.update();
 
         //oldPosX = this.camera.position.x;
   
        //this.renderer.render(this.scene, this.camera);
        this.composer.render();
        //this.controls.update();


        newPosX = this.camera.position.x;
        dist =this.oldPosX - newPosX;
        this.oldPosX = newPosX;
        this.audioFlag = true;
        if (dist <0){
            dist = -(dist);

            if ( this.audioFlag == true && dist >300){
                this.audioFlag =false;
                audio.play();
            }

        }else{

            if ( this.audioFlag == true && dist >300){
                this.audioFlag =false;
                audio.play();
            }
        }


    };

    return Webgl;

})();
/**
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin 	/ http://mark-lundin.com
 */

THREE.TrackballControls = function ( object, domElement ) {

	var _this = this;
	var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// API

	this.enabled = true;

	this.screen = { left: 0, top: 0, width: 0, height: 0 };

	this.rotateSpeed = 1.0;
	this.zoomSpeed = 1.2;
	this.panSpeed = 0.3;

	this.noRotate = false;
	this.noZoom = false;
	this.noPan = false;
	this.noRoll = false;

	this.staticMoving = false;
	this.dynamicDampingFactor = 0.2;

	this.minDistance = 0;
	this.maxDistance = Infinity;

	this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

	// internals

	this.target = new THREE.Vector3();

	var EPS = 0.000001;

	var lastPosition = new THREE.Vector3();

	var _state = STATE.NONE,
	_prevState = STATE.NONE,

	_eye = new THREE.Vector3(),

	_rotateStart = new THREE.Vector3(),
	_rotateEnd = new THREE.Vector3(),

	_zoomStart = new THREE.Vector2(),
	_zoomEnd = new THREE.Vector2(),

	_touchZoomDistanceStart = 0,
	_touchZoomDistanceEnd = 0,

	_panStart = new THREE.Vector2(),
	_panEnd = new THREE.Vector2();

	// for reset

	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.up0 = this.object.up.clone();

	// events

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start'};
	var endEvent = { type: 'end'};


	// methods

	this.handleResize = function () {

		if ( this.domElement === document ) {

			this.screen.left = 0;
			this.screen.top = 0;
			this.screen.width = window.innerWidth;
			this.screen.height = window.innerHeight;

		} else {

			var box = this.domElement.getBoundingClientRect();
			// adjustments come from similar code in the jquery offset() function
			var d = this.domElement.ownerDocument.documentElement;
			this.screen.left = box.left + window.pageXOffset - d.clientLeft;
			this.screen.top = box.top + window.pageYOffset - d.clientTop;
			this.screen.width = box.width;
			this.screen.height = box.height;

		}

	};

	this.handleEvent = function ( event ) {

		if ( typeof this[ event.type ] == 'function' ) {

			this[ event.type ]( event );

		}

	};

	var getMouseOnScreen = ( function () {

		var vector = new THREE.Vector2();

		return function ( pageX, pageY ) {

			vector.set(
				( pageX - _this.screen.left ) / _this.screen.width,
				( pageY - _this.screen.top ) / _this.screen.height
			);

			return vector;

		};

	}() );

	var getMouseProjectionOnBall = ( function () {

		var vector = new THREE.Vector3();
		var objectUp = new THREE.Vector3();
		var mouseOnBall = new THREE.Vector3();

		return function ( pageX, pageY ) {

			mouseOnBall.set(
				( pageX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),
				( _this.screen.height * 0.5 + _this.screen.top - pageY ) / (_this.screen.height*.5),
				0.0
			);

			var length = mouseOnBall.length();

			if ( _this.noRoll ) {

				if ( length < Math.SQRT1_2 ) {

					mouseOnBall.z = Math.sqrt( 1.0 - length*length );

				} else {

					mouseOnBall.z = .5 / length;
					
				}

			} else if ( length > 1.0 ) {

				mouseOnBall.normalize();

			} else {

				mouseOnBall.z = Math.sqrt( 1.0 - length * length );

			}

			_eye.copy( _this.object.position ).sub( _this.target );

			vector.copy( _this.object.up ).setLength( mouseOnBall.y )
			vector.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );
			vector.add( _eye.setLength( mouseOnBall.z ) );

			return vector;

		};

	}() );

	this.rotateCamera = (function(){

		var axis = new THREE.Vector3(),
			quaternion = new THREE.Quaternion();


		return function () {

			var angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );

			if ( angle ) {

				axis.crossVectors( _rotateStart, _rotateEnd ).normalize();

				angle *= _this.rotateSpeed;

				quaternion.setFromAxisAngle( axis, -angle );

				_eye.applyQuaternion( quaternion );
				_this.object.up.applyQuaternion( quaternion );

				_rotateEnd.applyQuaternion( quaternion );

				if ( _this.staticMoving ) {

					_rotateStart.copy( _rotateEnd );

				} else {

					quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
					_rotateStart.applyQuaternion( quaternion );

				}

			}
		}

	}());

	this.zoomCamera = function () {

		if ( _state === STATE.TOUCH_ZOOM_PAN ) {

			var factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
			_touchZoomDistanceStart = _touchZoomDistanceEnd;
			_eye.multiplyScalar( factor );

		} else {

			var factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;

			if ( factor !== 1.0 && factor > 0.0 ) {

				_eye.multiplyScalar( factor );

				if ( _this.staticMoving ) {

					_zoomStart.copy( _zoomEnd );

				} else {

					_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;

				}

			}

		}

	};

	this.panCamera = (function(){

		var mouseChange = new THREE.Vector2(),
			objectUp = new THREE.Vector3(),
			pan = new THREE.Vector3();

		return function () {

			mouseChange.copy( _panEnd ).sub( _panStart );

			if ( mouseChange.lengthSq() ) {

				mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

				pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
				pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );

				_this.object.position.add( pan );
				_this.target.add( pan );

				if ( _this.staticMoving ) {

					_panStart.copy( _panEnd );

				} else {

					_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

				}

			}
		}

	}());

	this.checkDistances = function () {

		if ( !_this.noZoom || !_this.noPan ) {

			if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {

				_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );

			}

			if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {

				_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );

			}

		}

	};

	this.update = function () {

		_eye.subVectors( _this.object.position, _this.target );

		if ( !_this.noRotate ) {

			_this.rotateCamera();

		}

		if ( !_this.noZoom ) {

			_this.zoomCamera();

		}

		if ( !_this.noPan ) {

			_this.panCamera();

		}

		_this.object.position.addVectors( _this.target, _eye );

		_this.checkDistances();

		_this.object.lookAt( _this.target );

		if ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {

			_this.dispatchEvent( changeEvent );

			lastPosition.copy( _this.object.position );

		}

	};

	this.reset = function () {

		_state = STATE.NONE;
		_prevState = STATE.NONE;

		_this.target.copy( _this.target0 );
		_this.object.position.copy( _this.position0 );
		_this.object.up.copy( _this.up0 );

		_eye.subVectors( _this.object.position, _this.target );

		_this.object.lookAt( _this.target );

		_this.dispatchEvent( changeEvent );

		lastPosition.copy( _this.object.position );

	};

	// listeners

	function keydown( event ) {

		if ( _this.enabled === false ) return;

		window.removeEventListener( 'keydown', keydown );

		_prevState = _state;

		if ( _state !== STATE.NONE ) {

			return;

		} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {

			_state = STATE.ROTATE;

		} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {

			_state = STATE.ZOOM;

		} else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {

			_state = STATE.PAN;

		}

	}

	function keyup( event ) {

		if ( _this.enabled === false ) return;

		_state = _prevState;

		window.addEventListener( 'keydown', keydown, false );

	}

	function mousedown( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		if ( _state === STATE.NONE ) {

			_state = event.button;

		}

		if ( _state === STATE.ROTATE && !_this.noRotate ) {

			_rotateStart.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );
			_rotateEnd.copy( _rotateStart );

		} else if ( _state === STATE.ZOOM && !_this.noZoom ) {

			_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
			_zoomEnd.copy(_zoomStart);

		} else if ( _state === STATE.PAN && !_this.noPan ) {

			_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
			_panEnd.copy(_panStart)

		}

		document.addEventListener( 'mousemove', mousemove, false );
		document.addEventListener( 'mouseup', mouseup, false );

		_this.dispatchEvent( startEvent );

	}

	function mousemove( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		if ( _state === STATE.ROTATE && !_this.noRotate ) {

			_rotateEnd.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );

		} else if ( _state === STATE.ZOOM && !_this.noZoom ) {

			_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

		} else if ( _state === STATE.PAN && !_this.noPan ) {

			_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

		}

	}

	function mouseup( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		_state = STATE.NONE;

		document.removeEventListener( 'mousemove', mousemove );
		document.removeEventListener( 'mouseup', mouseup );
		_this.dispatchEvent( endEvent );

	}

	function mousewheel( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		var delta = 0;

		if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

			delta = event.wheelDelta / 40;

		} else if ( event.detail ) { // Firefox

			delta = - event.detail / 3;

		}

		_zoomStart.y += delta * 0.01;
		_this.dispatchEvent( startEvent );
		_this.dispatchEvent( endEvent );

	}

	function touchstart( event ) {

		if ( _this.enabled === false ) return;

		switch ( event.touches.length ) {

			case 1:
				_state = STATE.TOUCH_ROTATE;
				_rotateStart.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
				_rotateEnd.copy( _rotateStart );
				break;

			case 2:
				_state = STATE.TOUCH_ZOOM_PAN;
				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
				_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
				_panStart.copy( getMouseOnScreen( x, y ) );
				_panEnd.copy( _panStart );
				break;

			default:
				_state = STATE.NONE;

		}
		_this.dispatchEvent( startEvent );


	}

	function touchmove( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		switch ( event.touches.length ) {

			case 1:
				_rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
				break;

			case 2:
				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
				_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
				_panEnd.copy( getMouseOnScreen( x, y ) );
				break;

			default:
				_state = STATE.NONE;

		}

	}

	function touchend( event ) {

		if ( _this.enabled === false ) return;

		switch ( event.touches.length ) {

			case 1:
				_rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
				_rotateStart.copy( _rotateEnd );
				break;

			case 2:
				_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
				_panEnd.copy( getMouseOnScreen( x, y ) );
				_panStart.copy( _panEnd );
				break;

		}

		_state = STATE.NONE;
		_this.dispatchEvent( endEvent );

	}

	this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

	this.domElement.addEventListener( 'mousedown', mousedown, false );

	this.domElement.addEventListener( 'mousewheel', mousewheel, false );
	this.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox

	this.domElement.addEventListener( 'touchstart', touchstart, false );
	this.domElement.addEventListener( 'touchend', touchend, false );
	this.domElement.addEventListener( 'touchmove', touchmove, false );

	window.addEventListener( 'keydown', keydown, false );
	window.addEventListener( 'keyup', keyup, false );

	this.handleResize();

	// force an update at start
	this.update();

};

THREE.TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );
/**
 * Make all faces use unique vertices
 * so that each face can be separated from others
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ExplodeModifier = function () {

};

THREE.ExplodeModifier.prototype.modify = function ( geometry ) {

	var vertices = [];

	for ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {

		var n = vertices.length;

		var face = geometry.faces[ i ];

		var a = face.a;
		var b = face.b;
		var c = face.c;

		var va = geometry.vertices[ a ];
		var vb = geometry.vertices[ b ];
		var vc = geometry.vertices[ c ];

		vertices.push( va.clone() );
		vertices.push( vb.clone() );
		vertices.push( vc.clone() );

		face.a = n;
		face.b = n + 1;
		face.c = n + 2;

	}

	geometry.vertices = vertices;
	delete geometry.__tmpVertices;

}
var MiniPyramid = (function(){

    function MiniPyramid(){
        THREE.Object3D.call(this);

        var geometry = new THREE.CylinderGeometry( 0, 3, 3, 4, 1 );


        for ( var i = 0; i < geometry.faces.length; i ++ ) {
            geometry.faces[ i ].color.setHex( Math.random() * 0xffffff );      

        }


        var material = new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors , wireframe: false, side:THREE.DoubleSide} );
        //var material = new THREE.MeshBasicMaterial({color: 0x3facc8, wireframe: true});
        this.mesh = new THREE.Mesh(geometry, material);
        //THREE.ExplodeModifier.modify( geometry )
        this.add(this.mesh);


        
    }

    MiniPyramid.prototype = new THREE.Object3D;
    MiniPyramid.prototype.constructor = MiniPyramid;

    MiniPyramid.prototype.update = function() {
       // this.mesh.rotation.y += 0.01;
    };

    return MiniPyramid;
})();
var Pyramid = (function(){

    function Pyramid(){
        THREE.Object3D.call(this);

        var geometry = new THREE.CylinderGeometry( 0, 35, 40, 4, 1 );

        var material = new THREE.MeshPhongMaterial( { color: 0xffffff, wireframe: false} );
        
        this.mesh = new THREE.Mesh(geometry, material);
       
        this.add(this.mesh);

        this.particles = [];
        this.nbParticles = 100;
        var miniPyramid;

        this.tlExplode = new TimelineMax({onComplete: this.explodeCompleted, onCompleteScope: this});
        for ( var i = 0; i < this.nbParticles; i++ ) {

            miniPyramid = new MiniPyramid();
            miniPyramid.position.set(0, 0,0);
            
            miniPyramid.rotation.y = Math.PI*0.25;
            miniPyramid.mesh.visible = false;

            this.add(miniPyramid);
            this.particles.push(miniPyramid);

            this.tlExplode.to(miniPyramid.position, 2, {
                x: Math.random() * 4000 - 2000, 
                y: Math.random() * 1000 - 500, 
                z: Math.random() * 4000 - 2000,
            }, i * 0.001);
        }     
        this.tlExplode.pause(0);
        
    }

            


    Pyramid.prototype = new THREE.Object3D;
    Pyramid.prototype.constructor = Pyramid;


    Pyramid.prototype.explodeCompleted = function() {
        for ( var i = 0; i < this.nbParticles; i++ ) {
            this.particles[i].mesh.visible = false;
        }
    };

        
    Pyramid.prototype.explode= function(){
       
        this.mesh.visible = false;
        for ( var i = 0; i < this.nbParticles; i++ ) {
            this.particles[i].mesh.visible = true;
        }
        this.tlExplode.play(0);
              
    }

       Pyramid.prototype.rebootPyamid= function(){

        this.mesh.visible = true;


    }


    Pyramid.prototype.update = function() {
      
    };

    return Pyramid;
})();
var Sphere = (function(){

    function Sphere(){
        THREE.Object3D.call(this);

        var geometry = new THREE.SphereGeometry(35);
        var material = new THREE.MeshBasicMaterial({color: 0x3facc8, wireframe: true});
        this.mesh = new THREE.Mesh(geometry, material);
        this.add(this.mesh);
    }

    Sphere.prototype = new THREE.Object3D;
    Sphere.prototype.constructor = Sphere;

    Sphere.prototype.update = function() {
        this.mesh.rotation.y += 0.01;
    };

    return Sphere;
})();
// tween.js - http://github.com/sole/tween.js
'use strict';var TWEEN=TWEEN||function(){var a=[];return{REVISION:"7",getAll:function(){return a},removeAll:function(){a=[]},add:function(c){a.push(c)},remove:function(c){c=a.indexOf(c);-1!==c&&a.splice(c,1)},update:function(c){if(0===a.length)return!1;for(var b=0,d=a.length,c=void 0!==c?c:Date.now();b<d;)a[b].update(c)?b++:(a.splice(b,1),d--);return!0}}}();
TWEEN.Tween=function(a){var c={},b={},d=1E3,e=0,f=null,h=TWEEN.Easing.Linear.None,r=TWEEN.Interpolation.Linear,k=[],l=null,m=!1,n=null,p=null;this.to=function(a,c){null!==c&&(d=c);b=a;return this};this.start=function(d){TWEEN.add(this);m=!1;f=void 0!==d?d:Date.now();f+=e;for(var g in b)if(null!==a[g]){if(b[g]instanceof Array){if(0===b[g].length)continue;b[g]=[a[g]].concat(b[g])}c[g]=a[g]}return this};this.stop=function(){TWEEN.remove(this);return this};this.delay=function(a){e=a;return this};this.easing=
function(a){h=a;return this};this.interpolation=function(a){r=a;return this};this.chain=function(){k=arguments;return this};this.onStart=function(a){l=a;return this};this.onUpdate=function(a){n=a;return this};this.onComplete=function(a){p=a;return this};this.update=function(e){if(e<f)return!0;!1===m&&(null!==l&&l.call(a),m=!0);var g=(e-f)/d,g=1<g?1:g,i=h(g),j;for(j in c){var s=c[j],q=b[j];a[j]=q instanceof Array?r(q,i):s+(q-s)*i}null!==n&&n.call(a,i);if(1==g){null!==p&&p.call(a);g=0;for(i=k.length;g<
i;g++)k[g].start(e);return!1}return!0}};
TWEEN.Easing={Linear:{None:function(a){return a}},Quadratic:{In:function(a){return a*a},Out:function(a){return a*(2-a)},InOut:function(a){return 1>(a*=2)?0.5*a*a:-0.5*(--a*(a-2)-1)}},Cubic:{In:function(a){return a*a*a},Out:function(a){return--a*a*a+1},InOut:function(a){return 1>(a*=2)?0.5*a*a*a:0.5*((a-=2)*a*a+2)}},Quartic:{In:function(a){return a*a*a*a},Out:function(a){return 1- --a*a*a*a},InOut:function(a){return 1>(a*=2)?0.5*a*a*a*a:-0.5*((a-=2)*a*a*a-2)}},Quintic:{In:function(a){return a*a*a*
a*a},Out:function(a){return--a*a*a*a*a+1},InOut:function(a){return 1>(a*=2)?0.5*a*a*a*a*a:0.5*((a-=2)*a*a*a*a+2)}},Sinusoidal:{In:function(a){return 1-Math.cos(a*Math.PI/2)},Out:function(a){return Math.sin(a*Math.PI/2)},InOut:function(a){return 0.5*(1-Math.cos(Math.PI*a))}},Exponential:{In:function(a){return 0===a?0:Math.pow(1024,a-1)},Out:function(a){return 1===a?1:1-Math.pow(2,-10*a)},InOut:function(a){return 0===a?0:1===a?1:1>(a*=2)?0.5*Math.pow(1024,a-1):0.5*(-Math.pow(2,-10*(a-1))+2)}},Circular:{In:function(a){return 1-
Math.sqrt(1-a*a)},Out:function(a){return Math.sqrt(1- --a*a)},InOut:function(a){return 1>(a*=2)?-0.5*(Math.sqrt(1-a*a)-1):0.5*(Math.sqrt(1-(a-=2)*a)+1)}},Elastic:{In:function(a){var c,b=0.1;if(0===a)return 0;if(1===a)return 1;!b||1>b?(b=1,c=0.1):c=0.4*Math.asin(1/b)/(2*Math.PI);return-(b*Math.pow(2,10*(a-=1))*Math.sin((a-c)*2*Math.PI/0.4))},Out:function(a){var c,b=0.1;if(0===a)return 0;if(1===a)return 1;!b||1>b?(b=1,c=0.1):c=0.4*Math.asin(1/b)/(2*Math.PI);return b*Math.pow(2,-10*a)*Math.sin((a-c)*
2*Math.PI/0.4)+1},InOut:function(a){var c,b=0.1;if(0===a)return 0;if(1===a)return 1;!b||1>b?(b=1,c=0.1):c=0.4*Math.asin(1/b)/(2*Math.PI);return 1>(a*=2)?-0.5*b*Math.pow(2,10*(a-=1))*Math.sin((a-c)*2*Math.PI/0.4):0.5*b*Math.pow(2,-10*(a-=1))*Math.sin((a-c)*2*Math.PI/0.4)+1}},Back:{In:function(a){return a*a*(2.70158*a-1.70158)},Out:function(a){return--a*a*(2.70158*a+1.70158)+1},InOut:function(a){return 1>(a*=2)?0.5*a*a*(3.5949095*a-2.5949095):0.5*((a-=2)*a*(3.5949095*a+2.5949095)+2)}},Bounce:{In:function(a){return 1-
TWEEN.Easing.Bounce.Out(1-a)},Out:function(a){return a<1/2.75?7.5625*a*a:a<2/2.75?7.5625*(a-=1.5/2.75)*a+0.75:a<2.5/2.75?7.5625*(a-=2.25/2.75)*a+0.9375:7.5625*(a-=2.625/2.75)*a+0.984375},InOut:function(a){return 0.5>a?0.5*TWEEN.Easing.Bounce.In(2*a):0.5*TWEEN.Easing.Bounce.Out(2*a-1)+0.5}}};
TWEEN.Interpolation={Linear:function(a,c){var b=a.length-1,d=b*c,e=Math.floor(d),f=TWEEN.Interpolation.Utils.Linear;return 0>c?f(a[0],a[1],d):1<c?f(a[b],a[b-1],b-d):f(a[e],a[e+1>b?b:e+1],d-e)},Bezier:function(a,c){var b=0,d=a.length-1,e=Math.pow,f=TWEEN.Interpolation.Utils.Bernstein,h;for(h=0;h<=d;h++)b+=e(1-c,d-h)*e(c,h)*a[h]*f(d,h);return b},CatmullRom:function(a,c){var b=a.length-1,d=b*c,e=Math.floor(d),f=TWEEN.Interpolation.Utils.CatmullRom;return a[0]===a[b]?(0>c&&(e=Math.floor(d=b*(1+c))),f(a[(e-
1+b)%b],a[e],a[(e+1)%b],a[(e+2)%b],d-e)):0>c?a[0]-(f(a[0],a[0],a[1],a[1],-d)-a[0]):1<c?a[b]-(f(a[b],a[b],a[b-1],a[b-1],d-b)-a[b]):f(a[e?e-1:0],a[e],a[b<e+1?b:e+1],a[b<e+2?b:e+2],d-e)},Utils:{Linear:function(a,c,b){return(c-a)*b+a},Bernstein:function(a,c){var b=TWEEN.Interpolation.Utils.Factorial;return b(a)/b(c)/b(a-c)},Factorial:function(){var a=[1];return function(c){var b=1,d;if(a[c])return a[c];for(d=c;1<d;d--)b*=d;return a[c]=b}}(),CatmullRom:function(a,c,b,d,e){var a=0.5*(b-a),d=0.5*(d-c),f=
e*e;return(2*c-2*b+a+d)*e*f+(-3*c+3*b-2*a-d)*f+a*e+c}}};
//# sourceMappingURL=app.min.js.map